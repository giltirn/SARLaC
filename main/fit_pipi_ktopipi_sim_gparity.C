#include<numeric_tensors.h>
#include<common_defs.h>
#include<parser.h>
#include<fit_wrapper.h>
#include<fit_wrapper_freeze.h>
#include <boost/timer/timer.hpp>

typedef correlationFunction<double,doubleJackknifeDistributionD> doubleJackCorrelationFunction;
#include <fit_ktopipi_gparity/fitfunc.h>

#include <fit_pipi_ktopipi_sim_gparity/fitfunc.h>
#include <fit_pipi_ktopipi_sim_gparity/main.h>
#include <fit_pipi_ktopipi_sim_gparity/args.h>
#include <fit_pipi_ktopipi_sim_gparity/fit.h>

int main(const int argc, const char** argv){
  assert(argc >= 2);
  Args args;  
  parse(args,argv[1]);

  //We assume that the data has previously been generated by their independent fit programs
  doubleJackCorrelationFunction pipi_data_dj;
  {
    HDF5reader reader(args.pipi_combined_data_file);
    read(reader, pipi_data_dj, "data");
  }
  std::vector<jackAmplitudeCorrelationFunction> ktopipi_data_j;
  std::vector<doubleJackAmplitudeCorrelationFunction> ktopipi_data_dj;
  {
    HDF5reader reader(args.ktopipi_amplitude_data_file);
    read(reader, ktopipi_data_j, "A0_all_j");
    read(reader, ktopipi_data_dj, "A0_all_dj");
  }
  assert(ktopipi_data_dj.size() == ktopipi_data_j.size());

  const int nsample = pipi_data_dj.value(0).size();

  //Fold the Pipi data (in my pipi code it is already folded, but in principle you could load unfolded data)
  const int Tref = args.Lt-2*args.tsep_pipi;
  doubleJackCorrelationFunction pipi_data_folded_dj(args.Lt,
						    [&](const int t){
						      return typename doubleJackCorrelationFunction::ElementType(pipi_data_dj.coord(t),
														 ( pipi_data_dj.value(t) + pipi_data_dj.value( (Tref-t+args.Lt) % args.Lt ) )/2.
														 );
						    });
  
  //Get data in fit range
  doubleJackCorrelationFunction pipi_data_inrange_dj;
  for(int i=0;i<pipi_data_dj.size();i++)
    if(int(pipi_data_folded_dj.coord(i)) >= args.tmin_pipi && int(pipi_data_folded_dj.coord(i)) <= args.tmax_pipi)
      pipi_data_inrange_dj.push_back(pipi_data_folded_dj[i]);
  
  std::vector<jackAmplitudeCorrelationFunction> ktopipi_data_inrange_j(10);
  std::vector<doubleJackAmplitudeCorrelationFunction> ktopipi_data_inrange_dj(10);
  for(int q=0;q<10;q++){  
    for(int i=0;i<ktopipi_data_j[q].size();i++){
      const int t = int(ktopipi_data_j[q].coord(i).t);
      const int tsep_k_pi = ktopipi_data_j[q].coord(i).tsep_k_pi;
      const int tsep_op_pi = tsep_k_pi - t;
      if(t <= tsep_k_pi && t >= args.tmin_k_op && tsep_op_pi >= args.tmin_op_pi){
	ktopipi_data_inrange_j[q].push_back(ktopipi_data_j[q][i]);
	ktopipi_data_inrange_dj[q].push_back(ktopipi_data_dj[q][i]);
      }
    }
  }
    
  //Combine into single container for fitting
  jackAmplitudeSimCorrelationFunction data_combined_j;
  doubleJackAmplitudeSimCorrelationFunction data_combined_dj;
  
  insertPipi(data_combined_j,data_combined_dj,pipi_data_inrange_dj);
  convertChiralBasisAndInsertKtoPipi(data_combined_j,data_combined_dj,ktopipi_data_inrange_j,ktopipi_data_inrange_dj);

  std::cout << "Data included:\n";
  for(int i=0;i<data_combined_j.size();i++){
    if(data_combined_j.coord(i).idx == -1){
      std::cout << "PiPi t=" << data_combined_j.coord(i).t << " value=" << data_combined_j.value(i) << std::endl;
    }else{
      std::cout << "KtoPiPi " << data_combined_j.coord(i) << " value=" << data_combined_j.value(i) << std::endl;
    }
  }

  FitFunc fitfunc(args.Lt,args.tsep_pipi,args.Ascale,args.Cscale);
  fit(fitfunc,data_combined_j,data_combined_dj,args);

  std::cout << "Done\n";
  
  return 0;
}

